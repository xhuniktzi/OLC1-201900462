package olc1.project1.analizadores;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import olc1.project1.instructions.Statement;
import olc1.project1.instructions.Operation;
import olc1.project1.instructions.Param;

import olc1.project1.instructions.Assignment;

import olc1.project1.instructions.EnumOperations;
import olc1.project1.instructions.EnumTerminals;
import olc1.project1.instructions.EnumUnitaryOperations;
import olc1.project1.instructions.EnumTypes;

parser code 
{:
     public LinkedList<Statement> AST;

    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la linea: " + (s.left) + " y columna : " + s.right + ". No se esperaba este token: " + s.value + "."); 
    } 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico irrecuperable en la línea " + (s.left) + " y columna " + s.right + ". Componente " + s.value + " no reconocido."); 
    }  
  
:}

terminal String MAJOR, MINOR, MAJOREQUALS, MINOREQUALS, EQUALS, NOTEQUALS, NOT, OR, AND;
terminal String COMMA, DOTCOMMA, OPENQUESTION, CLOSEQUESTION;
terminal String ADD, SUBSTRACT, MULTIPLY, DIVISION;
terminal String POW, MODULE;
terminal String PARSTART, PAREND;
terminal String START, END;
terminal String ARROW;
terminal String ENTER, AS, WITH_VALUE;
terminal String IF, THEN, ENDIF, ELSE, ELIF;
terminal String SWITCH, DO, ENDSWITCH;
terminal String FOR, TO, ENDFOR, WITHINCREMENTAL;
terminal String WHILE, ENDWHILE;
terminal String REPEAT, ENDREPEAT;
terminal String RETURN, DEFPROCEDURE, ENDPROCEDURE, PARAMS;
terminal String FUNCTION, ENDFUNCTION, EXEC;
terminal String PRINT, PRINTLN;
terminal String NUM, STR, BOOLEAN, CHAR;
terminal String TYPEDEF, ID, FUNCID;

non terminal ini;

non terminal LinkedList<Statement> statements;
non terminal Statement statement;
non terminal Operation expr;
non terminal LinkedList<String> name_list;
non terminal LinkedList<Param> params_list;
non terminal LinkedList<Operation> args_list;
non terminal func;
non terminal elifs;
non terminal cases;

precedence left MAJOR, MINOR, MAJOREQUALS, MINOREQUALS, EQUALS, NOTEQUALS;
precedence left AND, OR; 
precedence left ADD, SUBSTRACT;
precedence left MULTIPLY, DIVISION;
precedence left POW, MODULE;

start with ini;

ini ::= START statements:s END {:parser.AST=s;:}
| START END;

statements ::= statements:s statement:t {:RESULT=s; RESULT.add(t);:}
| statement:s {:RESULT = new LinkedList<Statement>(); RESULT.add(s);:};

statement ::= ENTER name_list:n AS TYPEDEF:t WITH_VALUE expr:e DOTCOMMA {:RESULT = new Assignment(n, t, e);:}
| name_list ARROW expr DOTCOMMA
| IF expr THEN statements ENDIF
| IF expr THEN statements ELSE statements ENDIF
| IF expr THEN statements elifs ENDIF
| IF expr THEN statements elifs ELSE statements ENDIF
| FOR ID ARROW expr TO expr DO statements ENDFOR
| FOR ID ARROW expr TO expr WITHINCREMENTAL expr DO statements ENDFOR
| FOR ID ARROW expr TO expr DO ENDFOR
| FOR ID ARROW expr TO expr WITHINCREMENTAL expr DO ENDFOR
| WHILE expr DO statements ENDWHILE
| REPEAT statements ENDREPEAT expr
| WHILE expr DO ENDWHILE
| REPEAT ENDREPEAT expr
| RETURN expr DOTCOMMA
| DEFPROCEDURE FUNCID statements ENDPROCEDURE
| DEFPROCEDURE FUNCID PARAMS PARSTART params_list PAREND statements ENDPROCEDURE
| FUNCTION FUNCID TYPEDEF statements ENDFUNCTION
| FUNCTION FUNCID TYPEDEF PARAMS PARSTART params_list PAREND statements ENDFUNCTION
| EXEC func DOTCOMMA
| PRINT expr DOTCOMMA
| PRINTLN expr DOTCOMMA
| SWITCH expr DO cases ENDSWITCH
| SWITCH expr DO cases ELSE statements ENDSWITCH;

params_list ::= params_list:p COMMA ID:i TYPEDEF:t {:RESULT = p; RESULT.add(new Param(i, t));:}
| ID:i TYPEDEF:t {:RESULT = new LinkedList<Param>(); RESULT.add(new Param(i, t));:};

args_list ::= args_list:a COMMA expr:e {:RESULT = a; RESULT.add(e);:}
| expr:e {:RESULT = new LinkedList<Operation>(); RESULT.add(e);:};

name_list ::= name_list:n COMMA ID:i {:RESULT = n; RESULT.add(i);:}
| ID:i {:RESULT = new LinkedList<String>(); RESULT.add(i);:};

func ::= FUNCID PARSTART PAREND
| FUNCID PARSTART args_list PAREND;

elifs ::= elifs ELIF expr THEN statements
| ELIF expr THEN statements;

cases ::= cases OPENQUESTION expr CLOSEQUESTION THEN statements
| OPENQUESTION expr CLOSEQUESTION THEN statements;

expr ::= ID:i {:RESULT = new Operation(i, EnumTerminals.ID);:}
| NUM:n {:RESULT = new Operation(n, EnumTerminals.NUM);:}
| STR:s {:RESULT = new Operation(s, EnumTerminals.STR);:}
| BOOLEAN:b {:RESULT = new Operation(b, EnumTerminals.BOOLEAN);:}
| CHAR:c {:RESULT = new Operation(c, EnumTerminals.CHAR);:}
| SUBSTRACT expr:e {:RESULT = new Operation(e, EnumUnitaryOperations.NEGATIVE);:}
| NOT expr:e {:RESULT = new Operation(e, EnumUnitaryOperations.NOT);:}
| expr:a ADD expr:b {:RESULT = new Operation(a, EnumOperations.ADD, b);:}
| expr:a SUBSTRACT expr:b {:RESULT = new Operation(a, EnumOperations.SUBSTRACT, b);:}
| expr:a MULTIPLY expr:b {:RESULT = new Operation(a, EnumOperations.MULTIPLY, b);:}
| expr:a DIVISION expr:b {:RESULT = new Operation(a, EnumOperations.DIVISION, b);:}
| expr:a POW expr:b {:RESULT = new Operation(a, EnumOperations.POW, b);:}
| expr:a MODULE expr:b {:RESULT = new Operation(a, EnumOperations.MODULE, b);:}
| expr:a MAJOR expr:b {:RESULT = new Operation(a, EnumOperations.MAJOR, b);:}
| expr:a MINOR expr:b {:RESULT = new Operation(a, EnumOperations.MINOR, b);:}
| expr:a MAJOREQUALS expr:b {:RESULT = new Operation(a, EnumOperations.MAJOREQUALS, b);:}
| expr:a MINOREQUALS expr:b {:RESULT = new Operation(a, EnumOperations.MINOREQUALS, b);:}
| expr:a EQUALS expr:b {:RESULT = new Operation(a, EnumOperations.EQUALS, b);:}
| expr:a NOTEQUALS expr:b {:RESULT = new Operation(a, EnumOperations.NOTEQUALS, b);:}
| expr:a AND expr:b {:RESULT = new Operation(a, EnumOperations.AND, b);:}
| expr:a OR expr:b {:RESULT = new Operation(a, EnumOperations.OR, b);:}
| PARSTART expr:e PAREND {:RESULT = e;:};